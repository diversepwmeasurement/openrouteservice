env:
  BUILD_PLATFORMS: linux/amd64,linux/arm64
  TEST_IMAGE_NAME: local/openrouteservice:test
jobs:
  build_docker_images:
    name: Build the docker images
    needs:
    - prepare_environment
    runs-on: self-hosted
    steps:
    - continue-on-error: true
      name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - continue-on-error: true
      name: Get and save the UID
      run: 'echo "UID=$(id -u)" >> $GITHUB_ENV

        '
    - continue-on-error: true
      name: Set up QEMU
      uses: docker/setup-qemu-action@v3
    - continue-on-error: true
      id: buildx
      name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        install: true
    - continue-on-error: true
      name: Build image for platforms ${{ needs.prepare_environment.outputs.build_platforms
        }}
      uses: docker/build-push-action@v4
      with:
        build-args: UID=${{ env.UID }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        context: .
        load: false
        platforms: ${{ needs.prepare_environment.outputs.build_platforms }}
        push: false
        tags: ${{ needs.prepare_environment.outputs.test_image_name }}
  prepare_environment:
    name: Prepare the environment variables
    outputs:
      build_platforms: ${{ env.BUILD_PLATFORMS }}
      test_image_name: ${{ env.TEST_IMAGE_NAME }}
    runs-on: self-hosted
    steps:
    - continue-on-error: true
      run: 'echo "Publish environment variables"

        '
  run_docker_image_tests:
    name: Run & test ${{ matrix.platform }}
    needs:
    - prepare_environment
    - build_docker_images
    runs-on: self-hosted
    steps:
    - continue-on-error: true
      run: 'echo "Run docker test for platform ${{ matrix.platform }}"

        '
    - continue-on-error: true
      name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - continue-on-error: true
      name: Get and save the UID
      run: 'echo "UID=$(id -u)" >> $GITHUB_ENV

        '
    - continue-on-error: true
      name: Set the wait time for arm64
      run: "if [[ \"${{ matrix.platform }}\" == 'linux/arm64' ]]; then\n  # arm64\
        \ is emulated and takes longer to build the graph\n  echo \"Set HEALTH_WAIT_TIME\
        \ to 600 for arm64\"\n  echo \"HEALTH_WAIT_TIME=600\" >> $GITHUB_ENV\nelse\n\
        \  echo \"Set HEALTH_WAIT_TIME to 260 for non-arm64\"\n  echo \"HEALTH_WAIT_TIME=260\"\
        \ >> $GITHUB_ENV\nfi\n"
    - continue-on-error: true
      name: Set up QEMU for ${{ matrix.platform }}
      uses: docker/setup-qemu-action@v3
      with:
        platforms: ${{ matrix.platform }}
    - continue-on-error: true
      id: buildx
      name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        install: true
    - continue-on-error: true
      name: Install jq
      uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: jq moreutils
        version: 1.0
    - continue-on-error: true
      name: Build image
      uses: docker/build-push-action@v4
      with:
        build-args: UID=${{ env.UID }}
        cache-from: type=gha
        context: .
        load: true
        platforms: ${{ matrix.platform }}
        push: false
        tags: ${{ needs.prepare_environment.outputs.test_image_name }}
    - continue-on-error: true
      name: Start container from previously build image and wait for successful checks
      run: "mkdir -p $(pwd)/graphs $(pwd)/config\nchown -R $UID $(pwd)/graphs $(pwd)/config\n\
        # Replace image: in the docker-compose.yml with the test image. The value\
        \ of image: can vary.\nsed -i \"s|image:.*|image: ${{ needs.prepare_environment.outputs.test_image_name\
        \ }}|\" docker-compose.yml\n# Start the first build with the docker-compose\
        \ setup\ndocker compose up --build -d\n# Wait for all logs to come in\nsleep\
        \ 5\ndocker compose logs ors-app\n ./.github/utils/url_check.sh 127.0.0.1\
        \ 8080 /ors/v2/health 200 ${{ env.HEALTH_WAIT_TIME }}\n# Stop the compose\
        \ setup and continue with docker run\ndocker compose down\n# Start the container\
        \ with the test image and the raw docker run command\ndocker run -it --user\
        \ $UID -d -p 8080:8082 -v $(pwd)/graphs:/home/ors/graphs -v $(pwd)/config:/home/ors/config\
        \ -v $(pwd)/ors-api/src/test/files/elevation:/home/ors/elevation_cache --name\
        \ ors-instance ${{ needs.prepare_environment.outputs.test_image_name }}\n\
        # Check for health to turn 200 after the graphs are build and spring-boot\
        \ completely started\n./.github/utils/url_check.sh 127.0.0.1 8080 /ors/v2/health\
        \ 200 ${{ env.HEALTH_WAIT_TIME }}\n# Check for correct preflight settings\
        \ to avoid CORS issues with ORIGIN wildcard from the example config\n./.github/utils/cors_check.sh\
        \ 127.0.0.1 8080 /ors/v2/isochrones/geojson \"https://example.org\" 200 10\n\
        ./.github/utils/cors_check.sh 127.0.0.1 8080 /ors/v2/isochrones/geojson \"\
        https://example.com\" 200 10\necho \"Adjust the config file and set ORIGIN\
        \ to https://example.org\"\nsudo yq '.ors.cors.allowed_origins = \"https://example.org,\
        \ https://test.com, http://localhost:8080\"' -i $(pwd)/config/ors-config.yml\n\
        # Restart the container to apply the config changes\ndocker restart ors-instance\n\
        # Request preflight with https://example.com and https://example.org to see\
        \ if it gets applied correctly\n./.github/utils/cors_check.sh 127.0.0.1 8080\
        \ /ors/v2/isochrones/geojson \"https://example.org\" 200 50\n# It should fail\
        \ with http code 403 for https://example.com since the Origin is not covered.\n\
        ./.github/utils/cors_check.sh 127.0.0.1 8080 /ors/v2/isochrones/geojson \"\
        https://example.com\" 403 10\necho \"Recreate the container to test if the\
        \ graph can be properly read again\"\ndocker stop ors-instance\ndocker container\
        \ prune -f \nchown -R $UID $(pwd)/graphs $(pwd)/config\ndocker run -it --user\
        \ $UID -d -p 8080:8082 -v $(pwd)/graphs:/home/ors/graphs -v $(pwd)/config:/home/ors/config\
        \ -e ors.cors.allowed_origins=https://example.org --name ors-instance ${{\
        \ needs.prepare_environment.outputs.test_image_name }}\n# Request preflight\
        \ with https://example.com and https://example.org to see if it gets applied\
        \ correctly\n./.github/utils/cors_check.sh 127.0.0.1 8080 /ors/v2/isochrones/geojson\
        \ \"https://example.org\" 200 50\n# It should fail with http code 403 for\
        \ https://example.com since the Origin is not covered.\n./.github/utils/cors_check.sh\
        \ 127.0.0.1 8080 /ors/v2/isochrones/geojson \"https://example.com\" 403 10\n"
    strategy:
      matrix:
        exclude:
        - isDraftPR: true
          platform: linux/arm64
        image:
        - ubuntu-latest
        isDraftPR:
        - ${{ github.event_name == 'pull_request' && github.event.pull_request.draft
          == true }}
        platform:
        - linux/amd64
        - linux/arm64
name: Build and test the Docker image
on:
  repository_dispatch:
    types: trigger-ga___docker-build-and-test.yml
